\subsection{Distance Estimation}

\subsubsection{Setup}

BlueCrystal4 was used to run the distance estimation pipeline across the dataset.
Minor adjustments to the load\_model() methods of the DPT and DepthAnything classes
were made in order to configure ONNX Runtime to utilise all CPU cores allocated by
SLURM (28 in this case).

It is also worth noting that for these distance estimation runs, the manual calibration
frame masks were used.
The reason for this was to maximise the consistency of the masks due to a drop in the
quality of the automated masks at longer distances
(see Section~\ref{subsec:analysis-of-calibration-frames}).

\subsubsection{Configurations}\label{subsubsec:configuratons}

Four distinct configurations of the distance estimation pipeline were applied to the
dataset.
Each configuration combined one of two detection methods (bounding box, segmentation) with one
of two distance estimation models (DPT, Depth Anything).
Using each of these configurations, distance estimates for both the manually and automatically
sampled detection frames were computed.

\vspace{5mm}
\textbf{Detection Methods}

Both detection methods use Mega Detector as a starting point to generate bounding boxes
enclosing the animal.

For the plain bounding box detection method, all pixels enclosed in the bounding boxes are used
as candidates during the later-stage calculation of detection distance from the depth maps
generated by either DPT or DepthAnything.
Specifically, once the depth estimation model has predicted a distance for each pixel, the
distance estimate for the entire detection is calculated to be equal to that of the pixel
corresponding to the 20th percentile depth of all pixels within the bounding box.

The segmentation method, however, introduces an additional step in which the generated bounding
boxes are passed to Segment Anything Model which subsequently predicts segmentation masks for
the detection.
It is these segmented pixels exclusively that are used in the later detection distance calculation.
In contrast to the plain BBOX detection method where distance is calculated based on
percentile, the segmentation method detection distance is calculated as equal to the distance
estimate of the pixel corresponding to the centre-most point of the segmentation mask (i.e., the pixel
that is furthest from the segmentation boundary).

Additionally, all runs using the segmentation detection method were parameterised with the
'calibration mask animals' flag.
This has the following effect:
During the detection calibration alignment where the scale of the furthest calibration frame reference
target is transferred to the detection frame, only the pixels inside the animal segmentation boundary
(rather than the entire bounding box) are excluded.
This is most impactful at very close detection distances where the animal occupies a significantly
large area of the frame, allowing for a more accurate alignment to be achieved.

\clearpage

\subsubsection{Testing Calibration Modifications}

The effects altering the calibration stage of the distance estimation pipeline were also tested.
Calibration frame preparation comprises significant manual annotation resulting in a bottleneck,
therefore it would be a positive outcome if this stage could be streamlined with a reduction in
calibration requirements.

Firstly, a modification was tested over the whole dataset with DPT distance estimation using both
bounding box and segmentation detection methods.
Here, the program's run() method was altered to ignore all calibration frames except those corresponding
to closest and furthest landmarks from the camera.

Secondly, the effects of varying the number of calibration frames was tested on a single camera
location.
A total of fifteen runs were carried out also using DPT distance estimation with both bounding box
and segmentation detection methods.
The first of these used a single (closest) calibration frame with each subsequent run then including
the next calibration frame in the sequence (i.e., 1, 1–2, 1–3, \ldots 1–15).
For the runs using at least two calibration frames (i.e., runs two through fifteen) a regression
function could be fitted as normal; however, this was not possible for the first run where a single
calibration frame was used.
Here, the calibrate() method was modified to return a simple scale factor transforming the single
modelled distance to its ground truth.